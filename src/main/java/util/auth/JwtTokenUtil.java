package util.auth;

import com.auth0.jwt.JWT;
import com.auth0.jwt.JWTVerifier;
import com.auth0.jwt.algorithms.Algorithm;
import com.auth0.jwt.interfaces.DecodedJWT;
import com.nimbusds.jose.*;
import com.nimbusds.jose.crypto.*;
import com.nimbusds.jose.jwk.RSAKey;

import java.security.KeyPair;
import java.security.KeyPairGenerator;
import java.security.NoSuchAlgorithmException;
import java.security.interfaces.RSAPublicKey;
import java.text.ParseException;
import java.util.Date;

/**
 * Utility class for generating, encrypting, decrypting, and verifying JWT tokens.
 * <p>
 * This class uses the RSA algorithm for encryption and decryption of JWT tokens. RSA is a public-key
 * encryption algorithm that provides secure data transmission. It's based on the principle that it's easy to
 * multiply large numbers, but factoring large numbers is computationally complex. In the context of JWT tokens,
 * RSA provides a means of assuring the integrity, authenticity, and non-repudiation of electronic communications
 * and data storage.
 * <p>
 * The RSA key pair used for encryption and decryption is generated at runtime and not stored in a file. This
 * means that the key pair is different every time the server is started. However, this is not a problem as users
 * are able to refresh their tokens using the refresh token.
 * <p>
 * The JWT tokens generated by this class have a default lifetime of 1 hour. This means that a token is valid for
 * 1 hour from the time it's generated. After this time, the token is expired and can no longer be used for
 * authentication. However, users can generate a new token using the refresh token.
 * <p>
 * The JWT tokens are encrypted using the RSA_OAEP_256 encryption algorithm and the A128GCM encryption method.
 * RSA_OAEP_256 is the RSAES OAEP using default parameters and SHA-256 algorithm, and A128GCM is the Advanced
 * Encryption Standard (AES) in Galois/Counter Mode (GCM) using 128 bit key. This combination of encryption
 * algorithm and method provides a high level of security for the JWT tokens.
 * <p>
 * This class provides the following public methods:
 * <ul>
 *     <li>{@link #decryptToken(String)}: Decrypts a JWT token using the RSA algorithm.</li>
 *     <li>{@link #verifyToken(String)}: Verifies a JWT token.</li>
 * </ul>
 * <p>
 * Note: This class should be used as a singleton to ensure that the same RSA key pair is used for all
 * encryption and decryption operations during the lifetime of the server.
 *
 * @see com.auth0.jwt.JWT
 * @see com.auth0.jwt.JWTVerifier
 * @see com.auth0.jwt.algorithms.Algorithm
 * @see com.auth0.jwt.interfaces.DecodedJWT
 * @see com.nimbusds.jose.JWEObject
 * @see com.nimbusds.jose.JWEHeader
 * @see com.nimbusds.jose.Payload
 * @see com.nimbusds.jose.crypto.RSAEncrypter
 * @see com.nimbusds.jose.crypto.RSADecrypter
 * @see com.nimbusds.jose.jwk.RSAKey
 */
public class JwtTokenUtil {

    /**
     * Static RSA key pair used for encrypting and decrypting JWT tokens.
     * In our case, this is generated at runtime, and not stored in a file.
     * Although this means that the key pair is different every time the server is started,
     * it is not a problem as users are able to refresh their tokens using the refresh token.
     * @see RefreshTokenUtil
     */
    private static final RSAKey RSA_KEY = generateRSAKeyPair();

    /**
     * Default lifetime of a JWT token in milliseconds.
     */
    private static final long DEFAULT_LIFETIME =  1000 * 60 * 60; // 1 hour

    // -- Private methods -- //

    /**
     * Generates a new RSA key pair.
     * @return the RSA key pair
     */
    private static RSAKey generateRSAKeyPair() throws RuntimeException {
        try {
            KeyPairGenerator keyGen = KeyPairGenerator.getInstance("RSA");
            keyGen.initialize(2048);
            KeyPair keyPair = keyGen.generateKeyPair();
            return new RSAKey.Builder((RSAPublicKey) keyPair.getPublic()).privateKey(keyPair.getPrivate()).build();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException("Failed to generate RSA key pair", e);
        }
    }

    /**
     * Method to generate a JWT token. Token is not encrypted.
     * @param subject the subject of the token
     * @return the JWT token
     */
    private String generateToken(String subject, int uid, long lifetime) {
        return JWT.create()
                .withSubject(subject)
                .withClaim("uid", uid)
                .withExpiresAt(new Date(System.currentTimeMillis() + lifetime))
                .sign(Algorithm.none());
    }

    /**
     * Encrypts a JWT token using the RSA algorithm.
     * @param payload the token to encrypt
     *
     */
    public String encryptToken(String payload) throws JOSEException {

        JWEObject jweObject = new JWEObject(
            new JWEHeader(JWEAlgorithm.RSA_OAEP_256, EncryptionMethod.A128GCM),
            new Payload(payload)
        );
        jweObject.encrypt(new RSAEncrypter(RSA_KEY));
        return jweObject.serialize();
    }


    // -- Public methods -- //

    /**
     * Generates an encrypted JWT token.
     * @param subject the subject of the token
     * @param uid the user id
     * @return the encrypted token
     * @see #generateEncryptedToken(String, int, long)
     */
    public String generateEncryptedToken(String subject, int uid) throws JOSEException {
        String payload = generateToken(subject, uid, DEFAULT_LIFETIME);
        return encryptToken(payload);
    }

    /**
     * Generates an encrypted JWT token.
     * Overloaded method to allow for a custom lifetime.
     * @param subject the subject of the token
     * @param uid the user id
     * @param lifetime the lifetime of the token in milliseconds
     * @return the encrypted token
     * @see #generateEncryptedToken(String, int)
     */
    public String generateEncryptedToken(String subject, int uid, long lifetime) throws JOSEException {
        String payload = generateToken(subject, uid, lifetime);
        return encryptToken(payload);
    }

    /**
     * Decrypts a JWT token using the RSA algorithm.
     * @param jweString the encrypted token
     * @return the decrypted token
     */
    public String decryptToken(String jweString) throws ParseException, JOSEException{
        JWEObject jweObject = JWEObject.parse(jweString);
        jweObject.decrypt(new RSADecrypter(RSA_KEY.toRSAPrivateKey()));
        return jweObject.getPayload().toString();
    }

    /**
     * Verifies a JWT token.
     * @param jweString the encrypted token
     * @return the decoded token
     */
    public DecodedJWT verifyToken(String jweString) throws Exception {
        JWTVerifier verifier = JWT.require(Algorithm.none()).build();
        return verifier.verify(jweString);
    }


}